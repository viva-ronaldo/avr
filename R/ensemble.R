#' Read in a csv file of candidates and ballots in standard format, 
#' with candidates as rows and ballots as columns, and no header
#' @param file_name The csv file containing votes
#' @return List of ballots, named ballot1, ballot2, etc.
#' @export
read_votes_from_csv <- function(file_name) {
    votes <- read.csv(file_name, header=FALSE, stringsAsFactors=FALSE)
    message(sprintf('%g candidates on ballot',nrow(votes)))
    message(sprintf('%g votes received',ncol(votes)-1))
    names(votes) <- c('Candidates', paste0('ballot',seq(ncol(votes)-1)))
    return(lapply(votes[2:ncol(votes)], function(b) ballot(b, map=votes$Candidates)))
}

#' Run stv multiple times and return elected frequencies,
#' to handle ties being broken randomly.
#' @param votes List of ballot objects, such as returned by read_votes_from_csv
#' @param nseats The number of seats available
#' @param nensemble The size of the ensemble to run
#' @param report If TRUE, generate an HTML report of the vote, 
#'   showing the possible count pathways and overall result (default: FALSE)
#' @param report_path If report is TRUE, the file name of the report
#'   (default: stv_ens_report.html)
#' @return An STV_ens object, containing:
#'   \describe{
#'     \item{ensemble_result:}{a table of all candidates elected at least once
#'       in the ensemble, and the percentage of iterations in which they were elected}
#'     \item{pathways:}{a list of the unique count pathways generated by the ensemble}
#' }
#' @export
ensemble_stv <- function(votes, nseats, nensemble,
                            report=FALSE, 
                            report_path=ifelse(report,'stv_ens_report.html',NULL)) {
    if (report) {
        #Need ggplot2, reshape2, kableExtra, formattable to make report
        if (length(intersect(c('ggplot2','reshape2','kableExtra','formattable'),
                             row.names(installed.packages()))) < 4) report <- FALSE
    }
    
    elected_counts <- list()
    running <- get_all_entries(votes)
    for (candidate in running) elected_counts[[candidate]] <- 0
    possible_count_tables <- c() 
    
    for (e in seq(nensemble)) {
        results <- stv(votes, nseats, getTable=TRUE, getMatrix=TRUE)  #TODO change to stv
        for (candidate in results$winners) {
            elected_counts[[candidate]] <- elected_counts[[candidate]] + 1
        }
        possible_count_tables <- union(possible_count_tables, list(results$count_table))
    }
    if (length(possible_count_tables) == 1) pathway_string <- '%i possible pathway' 
        else pathway_string <- '%i possible pathways'
    message(sprintf(pathway_string, length(possible_count_tables)))
    transfer_matrix <- results$transfer_matrix
    
    winner_freqs <- data.frame()
    for (winner in names(elected_counts[elected_counts > 0])) {
        winner_freqs <- rbind(winner_freqs,
                              data.frame(candidate=winner, elected_pct=100*elected_counts[[winner]]/nensemble))
    }
    ensemble_result <- winner_freqs[order(winner_freqs$elected_pct,decreasing=TRUE),]
    row.names(ensemble_result) <- seq(nrow(ensemble_result))
    
    stv_ens_results <- structure(
        list(nseats=nseats,
             nensemble=nensemble,
             nballots=length(votes),
             quota=droop_quota(length(votes),nseats),
             ensemble_result=ensemble_result,
             pathways=possible_count_tables,
             transfer_matrix=transfer_matrix),
        class = 'ens_STV'
    )
    
    #TODO avoid writing to tmp_
    if (report) {
        saveRDS(stv_ens_results, file='tmp_stv_ens_results.rds')
        report_text <- get_report_text(ensemble=TRUE,
                                       unanimous=(nrow(ensemble_result)==nseats))
        #cat(sprintf(report_text, 'tmp_stv_ens_results.rds'))
        cat(sprintf(report_text, 'tmp_stv_ens_results.rds'), file='tmp_stv_ens_report.rmd')
        capture.output(suppressMessages(rmarkdown::render('tmp_stv_ens_report.rmd', 
                                                          output_file=report_path, quiet=TRUE)))
        system('rm tmp_stv_ens_results.rds tmp_stv_ens_report.rmd')
        message(sprintf('Report written to %s',report_path))
    }
    
    return(stv_ens_results)
}

#' @export
print.ens_STV <- function(ens_stv) {
    #message("An avr ens_stv object.")
    print(ens_stv$ensemble_result)
    message("Winners:")
    invisible()
}

