#' Read in a csv file of candidates and ballots in standard format, 
#' with candidates as rows and ballots as columns, and no header,
#' or with candidates as columns and ballots as rows
#' @param file_name The csv file containing votes
#' @return List of ballots, named ballot1, ballot2, etc.
#' @export
read_votes_from_csv <- function(file_name, ballots_as_rows=FALSE) {
    if (ballots_as_rows | 
        sum(sapply(read.csv(file_name, nrows=1, header=FALSE), is.integer)) > 0) {
        votes <- read.csv(file_name, header=FALSE, stringsAsFactors=FALSE)
    } else {
        votes <- read.csv(file_name, header=TRUE)
        votes <- t(votes)
        votes <- data.frame(Candidates=row.names(votes), votes, stringsAsFactors = FALSE)
    }
    names(votes) <- c('Candidates', paste0('ballot',seq(ncol(votes)-1)))
    message(sprintf('%g candidates on ballot',nrow(votes)))
    message(sprintf('%g votes received',ncol(votes)-1))
    
    return(lapply(votes[2:ncol(votes)], function(b) ballot(b, map=votes$Candidates)))
}

#' Run stv multiple times and return elected frequencies,
#' to handle ties being broken randomly.
#' @param votes List of ballot objects, such as returned by read_votes_from_csv
#' @param nseats The number of seats available
#' @param nensemble The size of the ensemble to run
#' @param report If TRUE, generate an HTML report of the vote, 
#'   showing the possible count pathways and overall result (default: FALSE)
#' @param report_path If report is TRUE, the file name of the report
#'   (default: stv_ens_report.html)
#' @param use_fps_for_final_tie In STV, when on the last tie, split using FPs;
#'   (default: TRUE)
#' @param transfer_surplus In STV, do transfer votes from winners as well as losers.
#'   In certain circumstances it may be preferable to only transfer from losers
#'   (default: TRUE)
#' @return An STV_ens object, containing:
#'   \describe{
#'     \item{ensemble_result:}{a table of all candidates elected at least once
#'       in the ensemble, and the percentage of iterations in which they were elected}
#'     \item{pathways:}{a list of the unique count pathways generated by the ensemble}
#' }
#' @export
ensemble_stv <- function(votes, nseats, nensemble,
                         report=FALSE, 
                         report_path=ifelse(report,'stv_ens_report.html',NULL),
                         use_fps_for_final_tie=TRUE,
                         transfer_surplus=TRUE) {
    if (report) {
        #Need ggplot2, kableExtra, formattable to make report
        if (!requireNamespace(c("ggplot2","kableExtra","formattable"), quietly = TRUE)) {
            stop('You must install packages "ggplot2", "kableExtra", and "formattable" in order to generate a report.')
        }   
    }
    
    elected_counts <- list()
    running <- get_all_entries(votes)
    for (candidate in running) elected_counts[[candidate]] <- 0
    possible_count_tables <- c() 
    
    for (e in seq(nensemble)) {
        results <- stv(votes, nseats, getTable=TRUE, getMatrix=TRUE,
                       use_fps_for_final_tie = use_fps_for_final_tie,
                       transfer_surplus = transfer_surplus)
        for (candidate in results$winners) {
            elected_counts[[candidate]] <- elected_counts[[candidate]] + 1
        }
        possible_count_tables <- union(possible_count_tables, list(results$count_table))
    }
    if (length(possible_count_tables) == 1) pathway_string <- '%i possible pathway' 
        else pathway_string <- '%i possible pathways'
    message(sprintf(pathway_string, length(possible_count_tables)))
    #transfer_matrix <- results$transfer_matrix  #this is just the last one, not very useful
    
    winner_freqs <- data.frame()
    for (winner in names(elected_counts[elected_counts > 0])) {
        winner_freqs <- rbind(winner_freqs,
                              data.frame(candidate=winner, elected_pct=100*elected_counts[[winner]]/nensemble))
    }
    ensemble_result <- winner_freqs[order(winner_freqs$elected_pct,decreasing=TRUE),]
    row.names(ensemble_result) <- seq(nrow(ensemble_result))
    
    stv_ens_results <- structure(
        list(nseats = nseats,
             nensemble = nensemble,
             nballots = length(votes),
             candidates = running,
             quota = droop_quota(length(votes),nseats),
             ensemble_result = ensemble_result,
             pathways = possible_count_tables,
             votes = votes),
             #transfer_matrix=transfer_matrix),
        class = 'ens_STV'
    )
    
    #TODO avoid writing to tmp_
    if (report) {
        saveRDS(stv_ens_results, file='tmp_stv_ens_results.rds')
        report_text <- get_report_text(ensemble=TRUE,
                                       unanimous=(nrow(ensemble_result)==nseats))
        #cat(sprintf(report_text, 'tmp_stv_ens_results.rds'))
        cat(sprintf(report_text, 'tmp_stv_ens_results.rds'), file='tmp_stv_ens_report.rmd')
        capture.output(suppressMessages(rmarkdown::render('tmp_stv_ens_report.rmd', 
                                                          output_file=report_path, quiet=TRUE)))
        system('rm tmp_stv_ens_results.rds tmp_stv_ens_report.rmd')
        message(sprintf('Report written to %s',report_path))
    }
    
    return(stv_ens_results)
}

# stv_out$transfer_matrix$Donor <- row.names(stv_out$transfer_matrix)
# tra_grid_plot <- reshape2::melt(stv_out$transfer_matrix,id.vars='Donor',
#                                 variable.name='Recipient',value.name='Fraction')
# tra_grid_plot$Donor <- factor(tra_grid_plot$Donor,
#                               levels=levels(tra_grid_plot$Recipient))
# print(ggplot2::ggplot(tra_grid_plot,ggplot2::aes(Recipient,Donor)) + ggplot2::geom_tile(ggplot2::aes(fill=Fraction)) +
#           ggplot2::scale_fill_distiller(palette='Spectral',direction=-1) + ggplot2::theme_bw())

# transfers_full$Candidate <- factor(transfers_full$Candidate,
#                                    levels=rev(c('Avoca','Board','Bowling','Dinner','Escape','Laser')))
# transfers_full$Target <- factor(transfers_full$Target,
#                                 levels=c('Avoca','Board','Bowling','Dinner','Escape','Laser'))

#' @export
print.ens_STV <- function(ens_stv) {
    #message("An avr ens_stv object.")
    message("Winners:")
    print(ens_stv$ensemble_result)
    invisible()
}

